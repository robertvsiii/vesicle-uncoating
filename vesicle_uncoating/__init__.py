from SloppyCell.ReactionNetworks import *
from NetworkDef import net, MakeProbeNetwork, AddLipidAffinity
from DataImport import ImportData, MakeProbeModel, CleanParamList, StitchFiles, LoadData
from datetime import date
import numpy as np
import matplotlib.pyplot as plt
from multiprocessing import Pool, cpu_count
from functools import partial
from matplotlib.backends import backend_pdf as bpdf
import copy

net_base = net.copy()
defaultfolder = '/Users/Bobby/Dropbox (MIT)/MIT/EnglandGroup/Membranes/Lipid Sensor Paper Final Materials/Data/Processed Data/'
lipiddict = {'FYVE':'PI3P', 'PH':'PI45P2', 'TAPP1':'PI34P2', 'DrrA':'PI4P'}

CLTA_scale = 70.

class CoatedVesicle:
    """
    Creates network, experiment and model for given lipid probe and optimizable variables.
    
    priors = dictionary specifying prior probabilities. For example, {'ktest' : (3, 1)} would 
        make ktest an optimizable parameter, set 3 as the expected value, and allow the search
        to explore deviations from this value up to a factor of exp(1). 
    
    folder = folder in which data is stored. All new files generated by the code will also be saved there
    
    singletrack = True/False, determines whether cohort averaged data tracks are loaded, or pre-selected 
        single tracks. 
        
    filename_params = file name for saving and loading parameter values. Suffix is automatically added, and 
        should not be included here.
    
    filename_ens = file name for saving and loading parameter ensembles. Suffix is automatically added, and
        should not be included here.
        
    probechoice = enables construction of CoatedVesicle instances with some sensors excluded
    
    control = dictionary specifying whether to use control data with no clathrin-binding domain for each sensor
    
    saved = True/False, specifies whether parameters should be loaded from filename_params, or set to default
    """

    def __init__(self, priors = {}, folder = defaultfolder, singletrack = False,
                 filename_params = 'ProbeParams' + str(date.today()),
                 filename_ens = 'ProbeEns' + str(date.today()), probechoice = 'All', 
                 control = {'FYVE':True,'DrrA':True,'TAPP1':True,'PH':False}, saved = False):
        
        if probechoice in ['All', None]:
            self.probelist = ['FYVE', 'DrrA', 'PH', 'TAPP1']
        elif probechoice == 'NoPH':
            self.probelist = ['FYVE', 'DrrA', 'TAPP1']
        elif probechoice in ['FYVE', 'DrrA', 'PH', 'TAPP1']:
            self.probelist = [probechoice]
        elif probechoice == 'NoTAPP1':
            self.probelist = ['PH', 'FYVE', 'DrrA']
        else:
            print 'Invalid probe choice.'
            
        self.folder = folder
        self.filename_params = folder + filename_params + '.bp'
        self.filename_ens = folder + filename_ens + '.en'
        self.cpunum = cpu_count()
        
        self.priors = KeyedList(priors.copy())
        self.net_base = net_base.copy()
        self.net_probe = {}
        self.expt = {}
        self.probedata = {}
        self.CLTAdata = {}
        for probe in self.probelist:
            self.net_probe[probe] = MakeProbeNetwork(probe, self.net_base)
            self.expt[probe], self.probedata[probe], self.CLTAdata[probe] = ImportData(probe, self.folder, CLTA_scale, probechoice, control[probe], singletrack)
        self.model, self.params, self.cost = MakeProbeModel(self.net_probe, self.expt, self.priors)

        if saved:
            self.params = Utility.load(self.filename_params)
            
        self.model.params.update(self.params)
        self.params = self.model.params
        self.cost = self.model.cost(self.params)
        
        self.jtj_log = None
        self.cov = None
        self.ens = None
        self.tmax = 110
        
 
            
    def AddLipidAffinity(self, new_probed_lipid):
        AddLipidAffinity(new_probed_lipid,self.net_probe)
        
    def SetParams(self, params):
        """Set parameters (including non-optimizable parameters) to specified values in all networks"""
        
        for net in self.model.get_calcs():
            for name in params.keys():
                try:
                    net.set_var_val(name, params.get(name))
                except:
                    e = 1
                    
    def SetData(self, PROBE, t_data, CLTA_data, probe_data, sigmaprobe = 1, sigmaCLTA = 1, t_trunc = 0):
        """Load a new data set to replace the one automatically loaded using default file names."""
        
        probeerr = np.ones(len(t_data))*sigmaprobe
        CLTAerr = np.ones(len(t_data))*sigmaCLTA
        probedict = dict((t_data[k], (probe_data[k],probeerr[k])) for k in range(t_trunc,len(t_data)))
        CLTAdict = dict((t_data[k], (CLTA_data[k],CLTAerr[k])) for k in range(t_trunc,len(t_data)))
        expt = Experiment(PROBE)
        expt.set_data(dict([('net' + PROBE,dict([(PROBE,probedict),('CLTA',CLTAdict)]))]))
        self.expt[PROBE] = expt
        self.expt[PROBE].set_fixed_sf({'CLTA' : 1})
        self.expt[PROBE].set_fixed_sf({PROBE : 1})
        self.model, self.params, self.cost = MakeProbeModel(self.net_probe, self.expt, self.priors)
        self.model.params.update(self.params)
        self.params = self.model.params
        self.cost = self.model.cost(self.params)

    def GetTrajectory(self, PROBE):
        """Integrate sensor and lipid trajectory and using current parameter values"""
        
        self.net_probe[PROBE].update_optimizable_vars(self.params)
        traj = Dynamics.integrate(self.net_probe[PROBE], [0, self.tmax])
        t = traj.get_times()
        probe = traj.get_var_traj(PROBE)
        CLTA = traj.get_var_traj('CLTA')
        lipid = traj.get_var_traj(self.net_probe[PROBE].probed_lipid+'_tot')
        
        return t, CLTA, lipid, probe
        
    def GetBestFit(self, method = 'Nelder-Mead-log', tol = 1e-3):
        if method == 'Powell-log':
            self.params = Optimization.fmin_powell_log_params(self.model, self.params)
        elif method == 'Nelder-Mead-log':
            self.params = Optimization.fmin_log_params(self.model, self.params, xtol = tol)
        #elif method == 'Nelder-Mead': #NOT IMPLEMENTED
        #    self.params = Optimization.fmin(self.model, self.params)
        elif method == 'Levenberg-Marquadt-log':
            self.params = Optimization.fmin_lm_log_params(self.model, self.params)
        elif method == 'Least-Squares-log':
            self.params = Optimization.leastsq_log_params(self.model, self.params)
        else:
            print 'Invalid fit method.'
        Utility.save(self.params, self.filename_params)
        
        
    def GetEnsemble_cov(self, n_samples):
        if self.cov == None:
            if self.jtj_log == None:
                self.j_log, self.jtj_log = self.model.GetJandJtJInLogParameters(np.log(self.model.params))
            self.cov = np.linalg.inv(self.jtj_log)
            
        means = []
        params = self.model.params
        for j in range(len(params)):
            means.append(np.log(params[j]))
        means = np.asarray(means)
        params_sample = np.exp(np.random.multivariate_normal(means,self.cov,n_samples))
        
        return params_sample
        
    def GetEnsemble_MC(self, maxtime, skip = 0, temperature = 1, plotting = False, load_saved = False, sort = False):
        """Use Monte Carlo algorithm to numerically estimate parameter likelihood function."""
        
        if load_saved:
            self.ens, self.F, self.ratio = Utility.load(self.filename_ens)
            
        else:
            ensemble_partial = partial(Ensembles.ensemble_log_params, params = self.params, max_run_hours = maxtime,
                                      skip_elems = skip, temperature = temperature)
            models = []
            for n in range(self.cpunum):
                models.append(self.model.copy())
            
            pool = Pool(self.cpunum)
            results = pool.map(ensemble_partial, models)
            pool.close()
            
            self.ens = []
            self.F = []
            self.ratio = []
            for res in results:
                self.ens = self.ens + res[0]
                self.F = self.F + res[1]
                self.ratio.append(res[2])
            Utility.save([self.ens, self.F, self.ratio], self.filename_ens)
        
        if sort:
            temp = dict((self.F[j],self.ens[j]) for j in range(len(self.F)))
            self.ens = [value for (key,value) in sorted(temp.items())]
            self.F = [key for (key,value) in sorted(temp.items())]
        
        if plotting:
            self.F_autocorr = Ensembles.autocorrelation(self.F)[:round(len(self.F)/(2.*self.cpunum))]
            fig = plt.figure()
            ax1 = fig.add_subplot(211)
            ax1.plot(self.F)
            ax1.set_xlabel('Steps')
            ax1.set_ylabel('Cost')
            
            cutoff = 0.1
            ax2 = fig.add_subplot(212)
            ax2.plot(self.F_autocorr)
            ax2.set_xlabel('Lag')
            ax2.set_ylabel('Cost Autocorrelation')
    
    def PlotModel(self, datachoice = None):
        """Plot model results with data"""
        
        if datachoice == None:
            datachoice = [self.probelist[0]]
        self.model.CalculateForAllDataPoints(self.params)
        Plotting.figure(1)
        lines, labels = Plotting.plot_model_results(self.model, loc='upper left', data_to_plot = datachoice)
        return lines, labels
        
    def PlotSensitivity(self, variables, n = [100, 100], var_lims = [[0.1,10],[0.1,10]], levels = np.arange(2,50,2), 
                        vlim = [None, None], flip = False):
        """Plot 2D projection of log of parameter likelihood function
        
        variables = list of two variables to include
        
        n = number of grid points in each direction
        
        var_lims = axis limits for each parameter
        
        levels = contours to include
        
        vlim = axis limits for color bar (only relevant if Monte Carlo ensemble exists)
        
        flip = True/False flip axis direction
        
        WARNING: if variables are entered in the wrong order, elements of n and var_lims will be assigned to the 
        wrong axes. This should be easy to fix, though.
        
        If Monte-Carlo sampled parameters have been loaded into self.ens, these will also be plotted as a scatter
        plot with colors representing the value of the cost funtion.
        """
        
        fig1 = plt.figure(figsize = (5,5))
        ax1 = fig1.add_subplot(111)
        
        variable0 = variables[0]
        variable1 = variables[1]
        idx0 = self.model.params.index_by_key(variable0)
        idx1 = self.model.params.index_by_key(variable1)
        if idx0>idx1:
            variables[0] = variable1
            variables[1] = variable0
        
        jtj2_log, means_log, var_dict = self.IntegrateHessian(variables)
        self.sensitivity_variables = variables
        

        var_vals = [np.log(self.params.get(variables[0])), np.log(self.params.get(variables[1]))]
        var_ranges = [np.log(var_lims[0][1]) - np.log(var_lims[0][0]), np.log(var_lims[1][1]) - np.log(var_lims[1][0])]
        dtheta = np.asarray(var_ranges)*1./np.asarray(n)
        grd = np.mgrid[0:n[0],0:n[1]]
        theta = [grd[0]*dtheta[0] + np.log(var_lims[0][0]), grd[1]*dtheta[1] + np.log(var_lims[1][0])]
        Deltalogtheta = [theta[0] - var_vals[0], theta[1] - var_vals[1]]
        self.jtj2_log = jtj2_log
        C = 0.5*jtj2_log[0,0]*Deltalogtheta[0]**2 + jtj2_log[0,1]*Deltalogtheta[0]*Deltalogtheta[1] + 0.5*jtj2_log[1,1]*Deltalogtheta[1]**2
        for j in range(2):
            theta[j] = theta[j]*np.log10(np.exp(1))
            var_lims[j] = [np.log10(var_lims[j][0]),np.log10(var_lims[j][1])]
        if self.ens != None:
            theta_ens = [[],[]]
            cost = []
            for params in self.ens:
                theta_ens[0].append(np.log10(params.get(variables[0])))
                theta_ens[1].append(np.log10(params.get(variables[1])))
                scat = ax1.scatter(theta_ens[0],theta_ens[1],c=self.F,cmap='hot', 
                                   vmin = vlim[0], vmax = vlim[1])
                cbar = fig1.colorbar(scat)
                cbar.ax.set_ylabel('Cost')
                    
        self.contours = ax1.contour(theta[0], theta[1], np.exp(-C), levels, cmap = 'hot')
        cbar0 = fig1.colorbar(self.contours)
        cbar0.ax.set_ylabel(r'$p(\log$'+variables[0] + ', $\log$ '+variables[1] + ')')
        cbar0.set_ticks(())
        ax1.set_xlim(var_lims[0])
        ax1.set_ylim(var_lims[1])
        
        if flip:
            ax1.set_ylim(ax1.get_ylim()[::-1])
            
        ax1.set_xlabel(r'$\log$ '+variables[0])
        ax1.set_ylabel(r'$\log$ '+variables[1])
    
            #SAVE FIGURE
        pdf = bpdf.PdfPages(self.filename_ens + '_distribution.pdf')
        pdf.savefig(fig1)
        pdf.close()
        
        

    def IntegrateHessian(self, variables):
        """Projects Hessian down to the reduced set of variables included in the list "variables"
        """
        
        #NOTE: a simpler way to do this would be to just invert the matrix, remove the relevant rows/columns,
        #then invert again. I tested this, and it gives the same answer.
        if self.jtj_log == None:
            self.j_log, self.jtj_log = self.model.GetJandJtJInLogParameters(np.log(self.params))
        n_deleted = 0
        variables_idx = []
        jtj2_log = self.jtj_log.copy()
        means_log = []
        var_dict = {}
        new_idx = 0
        
        for item in variables:
            variables_idx.append(self.model.params.index_by_key(item))

        for var0 in range(np.size(self.jtj_log,0)):
            if var0 not in variables_idx:
                var = var0 - n_deleted
                a_log = jtj2_log[var,var]
                b_log = jtj2_log[:,var]
                b2_log = np.meshgrid(b_log,b_log)
                b2_log = b2_log[0]*b2_log[0].T
                jtj2_log = jtj2_log - b2_log/a_log
                jtj2_log = np.delete(jtj2_log, var, axis = 0)
                jtj2_log = np.delete(jtj2_log, var, axis = 1)
    
                n_deleted += 1
            else:
                name, value = self.model.params.items()[var0]
                means_log.append(np.log(value))
                var_dict[name] = new_idx
                new_idx += 1
        
        return jtj2_log, means_log, var_dict
    
    def SensitivityTable(self, ensemble = False, finite_diff = False, integrate = True, eps = 0.01):
        """Compute interquartile range for the likelihood distribution of each optimizable parameter
        
        ensemble = True/False, specifies whether to use the Monte Carlo ensemble instead of the Hessian
        
        finite_diff = True/False, specifies whether to compute the Hessian using a numerical finite-difference
            method or the (default and faster) analytic method based on integrating the sensitivity equations
            
        integrate = True/False, specifices whether to integrate out all the other variables from the likelihood
            function before computing the interquartile range
            
        eps = parameter for finite-difference evaluation
        """
        
        if self.jtj_log == None:
            self.j_log, self.jtj_log = self.model.GetJandJtJInLogParameters(np.log(self.model.params))
        self.cov = np.linalg.inv(self.jtj_log)
        if finite_diff:
            self.hess_log = self.model.hessian_log_params(self.model.params,eps)
            self.cov = np.linalg.inv(self.hess_log)
        
        self.ParamTable = dict()
        if ensemble:
            for variable in self.params.keys():
                log_values = []
                value = self.params.get(variable)
                for element in self.ens:
                    log_values.append(np.log(element.get(variable)))
                log_values = np.asarray(log_values)
                log_mean = np.mean(log_values)
                log_std = np.std(log_values)
                value_min = np.exp(log_mean-0.675*log_std)
                value_max = np.exp(log_mean+0.675*log_std)
                
                if variable in ['NPI3P', 'NPI34P2']:
                    value_min = 0
                    value_max = np.exp(np.max(log_values))
                    
                self.ParamTable[variable] = [value,(value_min, value_max)]
                if variable == 'ku0':
                    value_kex = self.Compute_kex(value)
                    value_min_kex = self.Compute_kex(value_min)
                    value_max_kex = self.Compute_kex(value_max)
                    self.ParamTable['kex'] = [value_kex,(value_min_kex, value_max_kex)]

                
        else:
            if integrate:
                for variable in self.model.params.keys():
                    value = self.model.params.get(variable)
                    idx = self.model.params.index_by_key(variable)
                    log_std = np.sqrt(self.cov[idx,idx])
                    value_min = np.exp(np.log(value)-0.675*log_std)
                    value_max = np.exp(np.log(value)+0.675*log_std)
                    self.ParamTable[variable] = [value,(value_min, value_max)]
                    if variable == 'ku0':
                        value_kex = self.Compute_kex(value)
                        value_min_kex = self.Compute_kex(value_min)
                        value_max_kex = self.Compute_kex(value_max)
                        self.ParamTable['kex'] = [value_kex,(value_min_kex, value_max_kex)]
                    if variable in ['N3k0','N4k0','N3k40','N5p0']:
                        kcat = self.model.get_calcs()[0].get_var_val('kcat'+variable[1:-1])
                        value = value*kcat
                        value_min = value_min*kcat
                        value_max = value_max*kcat
                        self.ParamTable[variable+'kcat'] = [value,(value_min,value_max)]
                        
            else:
                for variable in self.model.params.keys():
                    value = self.model.params.get(variable)
                    idx = self.model.params.index_by_key(variable)
                    log_std = np.sqrt(1/self.jtj_log[idx,idx])
                    value_min = np.exp(np.log(value)-2*log_std)
                    value_max = np.exp(np.log(value)+2*log_std)
                    self.ParamTable[variable] = [value,(value_min, value_max)]
                    if variable in ['N3k0','N4k0','N3k40','N5p0']:
                        kcat = self.model.get_calcs()[0].get_var_val('kcat'+variable[1:-1])
                        value = value*kcat
                        value_min = value_min*kcat
                        value_max = value_max*kcat
                        self.ParamTable[variable+'kcat'] = [value,(value_min,value_max)]
                    
        return self.ParamTable
    

    def ThesisTable(self):
        """Compute interquartile range for the likelihood distribution of each optimizable parameter
        
        ensemble = True/False, specifies whether to use the Monte Carlo ensemble instead of the Hessian
        
        finite_diff = True/False, specifies whether to compute the Hessian using a numerical finite-difference
            method or the (default and faster) analytic method based on integrating the sensitivity equations
            
        integrate = True/False, specifices whether to integrate out all the other variables from the likelihood
            function before computing the interquartile range
            
        eps = parameter for finite-difference evaluation
        """
        
        if self.jtj_log == None:
            self.j_log, self.jtj_log = self.model.GetJandJtJInLogParameters(np.log(self.model.params))
        self.cov = np.linalg.inv(self.jtj_log)
        
        self.ParamTable = dict()
 
        for variable in self.model.params.keys():
            value = self.model.params.get(variable)
            idx = self.model.params.index_by_key(variable)
            log_std = np.sqrt(self.cov[idx,idx])
            value_min = np.exp(np.log(value)-0.675*log_std)
            value_max = np.exp(np.log(value)+0.675*log_std)
            self.ParamTable[variable] = [value,(value_min, value_max)]

            if variable in ['N3k0','N4k0','N3k40','N5p0']:
                kcat = self.model.get_calcs()[0].get_var_val('kcat'+variable[1:-1])
                value = value*kcat
                value_min = value_min*kcat
                value_max = value_max*kcat
                
                PImax = self.model.get_calcs()[0].get_var_val('NPI')
                KM = self.model.get_calcs()[0].get_var_val('KM'+variable[1:-1])
                vmax = value/(1+KM/PImax)
                vmax_min = vmax*np.exp(-0.675*log_std)
                vmax_max = vmax*np.exp(0.675*log_std)
                
                self.ParamTable[variable+'kcat'] = [value,(value_min,value_max)]
                self.ParamTable['vmax'+variable[1:-1]] = [vmax,(vmax_min,vmax_max)]
            if variable == 'kcon0':
                self.ParamTable['kcon'] = [value/210,(value_min/210,value_max/210)]
                        
        for PROBE in lipiddict.keys()+['CLTA']:
            if PROBE in ['TAPP1','FYVE']:
                variables = ['kloff'+lipiddict[PROBE]+'_eff','klon','N'+PROBE]
                coeff = [1,-1,-1]
            elif PROBE == 'CLTA':
                variables = ['kcoff','kcon0']
                coeff = [1,-1]
            else:
                variables = ['kloff'+lipiddict[PROBE],'klon','N'+PROBE]
                coeff = [1,-1,-1]
            B = np.eye(np.size(self.cov,1))
            idx0 = self.model.params.index_by_key(variables[0])
            for k in range(len(variables)):
                idx = self.model.params.index_by_key(variables[k])
                B[idx0,idx] = coeff[k]
            value_log = B.dot(np.log(self.model.params))[idx0]
            self.covB = B.dot(self.cov.dot(B.T))
            log_std = np.sqrt(self.covB[idx0,idx0])
            value_min = np.exp(value_log-0.675*log_std)
            value_max = np.exp(value_log+0.675*log_std)
            if PROBE == 'CLTA':
                self.ParamTable['KD'+'CLTA'] = [np.exp(value_log)*210,(value_min*210, value_max*210)]
            else:
                self.ParamTable['KD'+lipiddict[PROBE]] = [np.exp(value_log),(value_min, value_max)]
            
        for PROBE in lipiddict.keys():
            variables = ['klon','N'+PROBE]
            coeff = [1,1]
            B = np.eye(np.size(self.cov,1))
            idx0 = self.model.params.index_by_key(variables[0])
            for k in range(len(variables)):
                idx = self.model.params.index_by_key(variables[k])
                B[idx0,idx] = coeff[k]
            value_log = B.dot(np.log(self.model.params))[idx0]
            self.covB = B.dot(self.cov.dot(B.T))
            log_std = np.sqrt(self.covB[idx0,idx0])
            value_min = np.exp(value_log-0.675*log_std)
            value_max = np.exp(value_log+0.675*log_std)
            self.ParamTable['N'+PROBE+'klon'] = [np.exp(value_log),(value_min, value_max)]
            

        return self.ParamTable
    
def MakeTraj(params,t=np.linspace(0,80,81)):
    """Makes dictionary of probe and lipid trajectories from given parameter set params.
    
       Lipid trajectories are generated in the absence of the corresponding sensor, so that the
       results are what would happen in the wild-type cells with no exogenous sensors expressed.
    """
    
    results = {}
    for PROBE in ['FYVE','DrrA','PH','TAPP1']:
        net_probe = MakeProbeNetwork(PROBE,net_base)
        if PROBE == 'FYVE':
            net_lipid = MakeProbeNetwork('DrrA',net_base)
        else:
            net_lipid = MakeProbeNetwork('FYVE',net_base)
        for name in params.keys():
            try:
                net_lipid.set_var_val(name,params.get(name))
            except:
                e = 1
            try:
                net_probe.set_var_val(name,params.get(name))
            except:
                e = 1
            
        traj_lipid = Dynamics.integrate(net_lipid, [0, max(t)])
        traj_probe = Dynamics.integrate(net_probe, [0, max(t)])
   
        results[PROBE] = {}
        results[PROBE]['lipid'] = np.interp(t,traj_lipid.get_times(),traj_lipid.get_var_traj(net_probe.probed_lipid))
        results[PROBE]['probe'] = np.interp(t,traj_probe.get_times(),traj_probe.get_var_traj(PROBE))
    results['time'] = t

    return results


def IntegrateAll(params_sample, params_template, extra_params = None, filename = 'ProbeEns' + str(date.today()),
                folder = defaultfolder):
    """Generates trajectories in parallel from a list of parameters params_sample.
    
       params_sample is a list of parameter lists. The parameters values within each list
       are taken to follow the same order as the parameters in the KeyedList params_template.
       
       A typical use case would be to take the same CoatedVesicle instance as was used to generate 
       params_sample, and pass vesicle.model.params to the params_template argument.
       
       extra_params are parameters that are not included in the params_sample list, but need to be
       changed from their default values. 
    """
    
    params = []

    for params_list in params_sample:
        params_single = params_template.copy()
        for k in range(len(params_list)):
            params_single[k] = params_list[k]
        if extra_params != None:
            for name in extra_params.keys():
                params_single.set(name,extra_params.get(name))
        params.append(params_single)

    pool = Pool()
    results = pool.map(MakeTraj,params)
    pool.close()

    lipid = {}
    probe = {}
    for LIPID in ['PI45P2','PI4P','PI3P','PI34P2']:
        lipid[LIPID] = []
        probe[LIPID] = []

    for result in results:
        for PROBE in lipiddict.keys():
            lipid[lipiddict[PROBE]].append(result[PROBE]['lipid'])
            probe[lipiddict[PROBE]].append(result[PROBE]['probe'])
    t = results[0]['time']
    
    Utility.save([lipid, probe, t], folder + filename + '_traj.en')
    Utility.save(params, folder + filename + '.en')
    
    return lipid, probe, t


def ConvertToKD(params,Nf = 1):
    """Converts kinetic parameters into dissociation constants, 
    assuming a cytosolic concentration Nf of sensor molecules (in uM)
    """
    
    KD_dict = {
        'Cytosolic concentration (uM)' : Nf,
        'Clathrin' : params.get('kcoff')*210*Nf/params.get('kcon0'),
    }

    for probe in ['PH','DrrA']:
        lipid = lipiddict[probe]
        KD_dict[lipid] = params.get('kloff'+lipid)*Nf/(params.get('klon')*params.get('N'+probe))
    for probe in ['FYVE','TAPP1']:
        lipid = lipiddict[probe]
        KD_dict[lipid] = params.get('kloff'+lipid+'_eff')*Nf/(params.get('klon')*params.get('N'+probe))
    return KD_dict